#!/bin/bash

BASE_BRANCH="origin/master"
_g_begin() {
  usage() {
    echo "Creates a new branch based off of $BASE_BRANCH"
  }
  case $1 in
    "" | -h | --help | help )
      usage
      return 0
    ;;
    * )
      git branch $1 $BASE_BRANCH --no-track
      git checkout $1
    ;;
  esac
}

_g_delete() {
  usage() {
    echo "Deletes local and remote branches of the same name."
  }

  case $1 in
    "" | -h | --help | help )
      usage
      return 0
    ;;
    * )
      git branch -D $1
      git push -d origin $1
    ;;
  esac
  
}

_g_pr() {
  usage() {
    echo "Pushes the current branch to the remote origin with the same name."
  }
  case $1 in
    -h | --help | help )
      usage
      return 0
    ;;
    * )
      feature_name=`git name-rev --name-only HEAD`
      git push origin $feature_name -u
    ;;
  esac
}

_g_sync() {
  usage() {
    echo "Sync to the latest from the remote and prune."
  }
  case $1 in
    -h | --help | help )
      usage
      return 0
    ;;
    * )
      git fetch -p
      git prune
      git merge
    ;;
  esac
}

_g_scan() {
  usage() {
    echo "Get the status of all branches"
  }
  case $1 in
    -h | --help | help )
      usage
      return 0
    ;;
  esac
  
  git for-each-ref --format="%(refname:short) %(upstream:short)" refs/heads | \
  while read local_ref remote_ref
  do
    remote_status=""
    if [ -z "$remote_ref" ]
    then
      remote_status=" !! "
      remote_ref="${BASE_BRANCH}"
    fi
    status=""
    git rev-list --left-right ${local_ref}...${remote_ref} -- 2>/dev/null >/tmp/git_upstream_status_delta || continue
    RIGHT_AHEAD=$(grep -c '^>' /tmp/git_upstream_status_delta)
    if [ $RIGHT_AHEAD -ne 0 ]
    then
      status="$status($RIGHT_AHEAD)<--|"
    fi
    LEFT_AHEAD=$(grep -c '^<' /tmp/git_upstream_status_delta)
    if [ $LEFT_AHEAD -ne 0 ]
    then
      status="${status}|-->($LEFT_AHEAD)"
    fi
    if [ -z "$status" ]
    then
      status="ok"
    fi
    echo "$local_ref <--> $remote_ref $remote_status [ $status ]"
  done
}

_g_dsquashed() {
  usage() {
    echo "Delete branches that have been squashed on remote"
  }
  case $1 in
    -h | --help | help )
      usage
      return 0
    ;;
  esac
  
  echo "**WIP**"
  i=0
  git fetch
  git for-each-ref refs/heads/ "--format=%(refname:short)" | \
  while read branch
  do
    mergeBase=$(git merge-base $BASE_BRANCH $branch)
    mergeStatus=$(git cherry $BASE_BRANCH $(git commit-tree $(git rev-parse $branch^{tree}) -p $mergeBase -m _))
    # echo "$branch mergeStatus: $mergeStatus mergeBase: $mergeBase"
    case $mergeStatus in
      "-"*) 
        i=$((i+1))
        echo "squashed: $branch is merged into $BASE_BRANCH and can be deleted"
        ;;
      *)    echo "not squashed: $branch is not merged into $BASE_BRANCH" ;;
    esac
  done
  echo "Deleted $i branches"
}